// Code generated by cborgen DO NOT EDIT.

package jetstreammeta

import (
	"time"

	cbor "github.com/synadia-labs/cbor-go/runtime"
)

func (x ClientInfo) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("host") + cbor.StringPrefixSize + len(x.Host) + cbor.StringPrefixSize + len("id") + cbor.Uint64Size + cbor.StringPrefixSize + len("acc") + cbor.StringPrefixSize + len(x.Account) + cbor.StringPrefixSize + len("svc") + cbor.StringPrefixSize + len(x.Service) + cbor.StringPrefixSize + len("user") + cbor.StringPrefixSize + len(x.User) + cbor.StringPrefixSize + len("name") + cbor.StringPrefixSize + len(x.Name) + cbor.StringPrefixSize + len("lang") + cbor.StringPrefixSize + len(x.Lang) + cbor.StringPrefixSize + len("ver") + cbor.StringPrefixSize + len(x.Version) + cbor.StringPrefixSize + len("rtt") + cbor.DurationSize + cbor.StringPrefixSize + len("server") + cbor.StringPrefixSize + len(x.Server) + cbor.StringPrefixSize + len("cluster") + cbor.StringPrefixSize + len(x.Cluster) + cbor.StringPrefixSize + len("alts") + cbor.ArrayHeaderSize + len(x.Alternates)*cbor.StringPrefixSize + cbor.StringPrefixSize + len("jwt") + cbor.StringPrefixSize + len(x.Jwt) + cbor.StringPrefixSize + len("issuer_key") + cbor.StringPrefixSize + len(x.IssuerKey) + cbor.StringPrefixSize + len("name_tag") + cbor.StringPrefixSize + len(x.NameTag) + cbor.StringPrefixSize + len("tags") + cbor.ArrayHeaderSize + len(x.Tags)*cbor.StringPrefixSize + cbor.StringPrefixSize + len("kind") + cbor.StringPrefixSize + len(x.Kind) + cbor.StringPrefixSize + len("client_type") + cbor.StringPrefixSize + len(x.ClientType) + cbor.StringPrefixSize + len("client_id") + cbor.StringPrefixSize + len(x.MQTTClient) + cbor.StringPrefixSize + len("nonce") + cbor.StringPrefixSize + len(x.Nonce)
	return
}

func (x *ClientInfo) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	if !(x.Start == nil) {
		count++
	}
	if !(x.Host == "") {
		count++
	}
	if !(x.ID == 0) {
		count++
	}
	if !(x.Account == "") {
		count++
	}
	if !(x.Service == "") {
		count++
	}
	if !(x.User == "") {
		count++
	}
	if !(x.Name == "") {
		count++
	}
	if !(x.Lang == "") {
		count++
	}
	if !(x.Version == "") {
		count++
	}
	if !(x.RTT == 0) {
		count++
	}
	if !(x.Server == "") {
		count++
	}
	if !(x.Cluster == "") {
		count++
	}
	if !(len(x.Alternates) == 0) {
		count++
	}
	if !(x.Stop == nil) {
		count++
	}
	if !(x.Jwt == "") {
		count++
	}
	if !(x.IssuerKey == "") {
		count++
	}
	if !(x.NameTag == "") {
		count++
	}
	if !(len(x.Tags) == 0) {
		count++
	}
	if !(x.Kind == "") {
		count++
	}
	if !(x.ClientType == "") {
		count++
	}
	if !(x.MQTTClient == "") {
		count++
	}
	if !(x.Nonce == "") {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	if !(x.Start == nil) {
		b = cbor.AppendString(b, "start")
		b, err = cbor.AppendInterface(b, x.Start)
		if err != nil {
			return b, err
		}
	}
	if !(x.Host == "") {
		b = cbor.AppendString(b, "host")
		b, err = cbor.AppendString(b, x.Host), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.ID == 0) {
		b = cbor.AppendString(b, "id")
		b, err = cbor.AppendUint64(b, x.ID), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Account == "") {
		b = cbor.AppendString(b, "acc")
		b, err = cbor.AppendString(b, x.Account), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Service == "") {
		b = cbor.AppendString(b, "svc")
		b, err = cbor.AppendString(b, x.Service), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.User == "") {
		b = cbor.AppendString(b, "user")
		b, err = cbor.AppendString(b, x.User), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Name == "") {
		b = cbor.AppendString(b, "name")
		b, err = cbor.AppendString(b, x.Name), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Lang == "") {
		b = cbor.AppendString(b, "lang")
		b, err = cbor.AppendString(b, x.Lang), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Version == "") {
		b = cbor.AppendString(b, "ver")
		b, err = cbor.AppendString(b, x.Version), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.RTT == 0) {
		b = cbor.AppendString(b, "rtt")
		b, err = cbor.AppendDuration(b, x.RTT), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Server == "") {
		b = cbor.AppendString(b, "server")
		b, err = cbor.AppendString(b, x.Server), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Cluster == "") {
		b = cbor.AppendString(b, "cluster")
		b, err = cbor.AppendString(b, x.Cluster), nil
		if err != nil {
			return b, err
		}
	}
	if !(len(x.Alternates) == 0) {

		b = cbor.AppendString(b, "alts")
		b = cbor.AppendArrayHeader(b, uint32(len(x.Alternates)))
		for _, v := range x.Alternates {
			b = cbor.AppendString(b, v)
		}
	}
	if !(x.Stop == nil) {
		b = cbor.AppendString(b, "stop")
		b, err = cbor.AppendInterface(b, x.Stop)
		if err != nil {
			return b, err
		}
	}
	if !(x.Jwt == "") {
		b = cbor.AppendString(b, "jwt")
		b, err = cbor.AppendString(b, x.Jwt), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.IssuerKey == "") {
		b = cbor.AppendString(b, "issuer_key")
		b, err = cbor.AppendString(b, x.IssuerKey), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.NameTag == "") {
		b = cbor.AppendString(b, "name_tag")
		b, err = cbor.AppendString(b, x.NameTag), nil
		if err != nil {
			return b, err
		}
	}
	if !(len(x.Tags) == 0) {

		b = cbor.AppendString(b, "tags")
		b = cbor.AppendArrayHeader(b, uint32(len(x.Tags)))
		for _, v := range x.Tags {
			b = cbor.AppendString(b, v)
		}
	}
	if !(x.Kind == "") {
		b = cbor.AppendString(b, "kind")
		b, err = cbor.AppendString(b, x.Kind), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.ClientType == "") {
		b = cbor.AppendString(b, "client_type")
		b, err = cbor.AppendString(b, x.ClientType), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.MQTTClient == "") {
		b = cbor.AppendString(b, "client_id")
		b, err = cbor.AppendString(b, x.MQTTClient), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Nonce == "") {
		b = cbor.AppendString(b, "nonce")
		b, err = cbor.AppendString(b, x.Nonce), nil
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ClientInfo) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "start":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "host":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Host = tmp
		case "id":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.ID = tmp
		case "acc":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Account = tmp
		case "svc":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Service = tmp
		case "user":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.User = tmp
		case "name":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "lang":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Lang = tmp
		case "ver":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Version = tmp
		case "rtt":

			var tmp time.Duration
			tmp, v, err = cbor.ReadDurationBytes(v)
			if err != nil {
				return b, err
			}
			x.RTT = tmp
		case "server":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Server = tmp
		case "cluster":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Cluster = tmp
		case "alts":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Alternates) >= int(sz) {
				x.Alternates = x.Alternates[:sz]
			} else {
				x.Alternates = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Alternates[sz-1]
			}
			for iAlternates := uint32(0); iAlternates < sz; iAlternates++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Alternates[iAlternates] = tmp
			}
		case "stop":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "jwt":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Jwt = tmp
		case "issuer_key":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.IssuerKey = tmp
		case "name_tag":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.NameTag = tmp
		case "tags":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Tags) >= int(sz) {
				x.Tags = x.Tags[:sz]
			} else {
				x.Tags = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Tags[sz-1]
			}
			for iTags := uint32(0); iTags < sz; iTags++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Tags[iTags] = tmp
			}
		case "kind":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Kind = tmp
		case "client_type":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.ClientType = tmp
		case "client_id":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.MQTTClient = tmp
		case "nonce":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Nonce = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ClientInfo) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "start":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "host":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Host = cbor.UnsafeString(tmpBytes)
		case "id":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.ID = tmp
		case "acc":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Account = cbor.UnsafeString(tmpBytes)
		case "svc":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Service = cbor.UnsafeString(tmpBytes)
		case "user":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.User = cbor.UnsafeString(tmpBytes)
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cbor.UnsafeString(tmpBytes)
		case "lang":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Lang = cbor.UnsafeString(tmpBytes)
		case "ver":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Version = cbor.UnsafeString(tmpBytes)
		case "rtt":

			var tmp time.Duration
			tmp, v, err = cbor.ReadDurationBytes(v)
			if err != nil {
				return b, err
			}
			x.RTT = tmp
		case "server":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Server = cbor.UnsafeString(tmpBytes)
		case "cluster":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Cluster = cbor.UnsafeString(tmpBytes)
		case "alts":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Alternates) >= int(sz) {
				x.Alternates = x.Alternates[:sz]
			} else {
				x.Alternates = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Alternates[sz-1]
			}
			for iAlternates := uint32(0); iAlternates < sz; iAlternates++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Alternates[iAlternates] = tmp
			}
		case "stop":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "jwt":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Jwt = cbor.UnsafeString(tmpBytes)
		case "issuer_key":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.IssuerKey = cbor.UnsafeString(tmpBytes)
		case "name_tag":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.NameTag = cbor.UnsafeString(tmpBytes)
		case "tags":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Tags) >= int(sz) {
				x.Tags = x.Tags[:sz]
			} else {
				x.Tags = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Tags[sz-1]
			}
			for iTags := uint32(0); iTags < sz; iTags++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Tags[iTags] = tmp
			}
		case "kind":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Kind = cbor.UnsafeString(tmpBytes)
		case "client_type":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.ClientType = cbor.UnsafeString(tmpBytes)
		case "client_id":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.MQTTClient = cbor.UnsafeString(tmpBytes)
		case "nonce":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Nonce = cbor.UnsafeString(tmpBytes)
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ClientInfo) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x RaftGroup) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("name") + cbor.StringPrefixSize + len(x.Name) + cbor.StringPrefixSize + len("peers") + cbor.ArrayHeaderSize + len(x.Peers)*cbor.StringPrefixSize + cbor.StringPrefixSize + len("cluster") + cbor.StringPrefixSize + len(x.Cluster) + cbor.StringPrefixSize + len("preferred") + cbor.StringPrefixSize + len(x.Preferred) + cbor.StringPrefixSize + len("scale_up") + cbor.BoolSize
	return
}

func (x *RaftGroup) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	count++
	count++
	count++
	if !(x.Cluster == "") {
		count++
	}
	if !(x.Preferred == "") {
		count++
	}
	if !(!x.ScaleUp) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	b = cbor.AppendString(b, "name")
	b, err = cbor.AppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}

	b = cbor.AppendString(b, "peers")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Peers)))
	for _, v := range x.Peers {
		b = cbor.AppendString(b, v)
	}
	b = cbor.AppendString(b, "store")
	b, err = x.Storage.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(x.Cluster == "") {
		b = cbor.AppendString(b, "cluster")
		b, err = cbor.AppendString(b, x.Cluster), nil
		if err != nil {
			return b, err
		}
	}
	if !(x.Preferred == "") {
		b = cbor.AppendString(b, "preferred")
		b, err = cbor.AppendString(b, x.Preferred), nil
		if err != nil {
			return b, err
		}
	}
	if !(!x.ScaleUp) {
		b = cbor.AppendString(b, "scale_up")
		b, err = cbor.AppendBool(b, x.ScaleUp), nil
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *RaftGroup) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "name":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "peers":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Peers) >= int(sz) {
				x.Peers = x.Peers[:sz]
			} else {
				x.Peers = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Peers[sz-1]
			}
			for iPeers := uint32(0); iPeers < sz; iPeers++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Peers[iPeers] = tmp
			}
		case "store":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "cluster":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Cluster = tmp
		case "preferred":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Preferred = tmp
		case "scale_up":

			var tmp bool
			tmp, v, err = cbor.ReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.ScaleUp = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *RaftGroup) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cbor.UnsafeString(tmpBytes)
		case "peers":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Peers) >= int(sz) {
				x.Peers = x.Peers[:sz]
			} else {
				x.Peers = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Peers[sz-1]
			}
			for iPeers := uint32(0); iPeers < sz; iPeers++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Peers[iPeers] = tmp
			}
		case "store":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "cluster":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Cluster = cbor.UnsafeString(tmpBytes)
		case "preferred":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Preferred = cbor.UnsafeString(tmpBytes)
		case "scale_up":

			var tmp bool
			tmp, v, err = cbor.ReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.ScaleUp = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *RaftGroup) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x SequencePair) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("consumer_seq") + cbor.Uint64Size + cbor.StringPrefixSize + len("stream_seq") + cbor.Uint64Size
	return
}

func (x *SequencePair) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	b = cbor.AppendMapHeader(b, uint32(2))
	var err error
	b = cbor.AppendString(b, "consumer_seq")
	b, err = cbor.AppendUint64(b, x.Consumer), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "stream_seq")
	b, err = cbor.AppendUint64(b, x.Stream), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *SequencePair) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "consumer_seq":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Consumer = tmp
		case "stream_seq":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *SequencePair) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "consumer_seq":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Consumer = tmp
		case "stream_seq":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *SequencePair) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x Pending) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("sequence") + cbor.Uint64Size + cbor.StringPrefixSize + len("ts") + cbor.Int64Size
	return
}

func (x *Pending) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	b = cbor.AppendMapHeader(b, uint32(2))
	var err error
	b = cbor.AppendString(b, "sequence")
	b, err = cbor.AppendUint64(b, x.Sequence), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "ts")
	b, err = cbor.AppendInt64(b, x.Timestamp), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Pending) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "sequence":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Sequence = tmp
		case "ts":

			var tmp int64
			tmp, v, err = cbor.ReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Timestamp = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Pending) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "sequence":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Sequence = tmp
		case "ts":

			var tmp int64
			tmp, v, err = cbor.ReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.Timestamp = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Pending) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x *ConsumerState) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	count := uint32(0)
	count++
	count++
	if !(len(x.Pending) == 0) {
		count++
	}
	if !(len(x.Redelivered) == 0) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	b = cbor.AppendString(b, "delivered")
	b, err = x.Delivered.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "ack_floor")
	b, err = x.AckFloor.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(len(x.Pending) == 0) {

		b = cbor.AppendString(b, "pending")
		b = cbor.AppendMapHeader(b, uint32(len(x.Pending)))
		for k, v := range x.Pending {
			b = cbor.AppendUint64(b, k)
			if v == nil {
				b = cbor.AppendNil(b)
			} else {
				b, err = v.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
		}
	}
	if !(len(x.Redelivered) == 0) {

		b = cbor.AppendString(b, "redelivered")
		b = cbor.AppendMapHeader(b, uint32(len(x.Redelivered)))
		for k, v := range x.Redelivered {
			b = cbor.AppendUint64(b, k)
			b = cbor.AppendUint64(b, v)
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ConsumerState) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "delivered":

			v, err = x.Delivered.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "ack_floor":

			v, err = x.AckFloor.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "pending":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Pending == nil && sz > 0 {
				x.Pending = make(map[uint64]*Pending, sz)
			} else if x.Pending != nil {
				clear(x.Pending)
			}
			for iPending := uint32(0); iPending < sz; iPending++ {
				var key uint64
				key, v, err = cbor.ReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				if len(v) == 0 {
					return b, cbor.ErrShortBytes
				}
				if v[0] == 0xf6 { // null
					var tmpBytes []byte
					tmpBytes, err = cbor.ReadNilBytes(v)
					if err != nil {
						return b, err
					}
					v = tmpBytes
					x.Pending[key] = nil
					continue
				}
				tmp := new(Pending)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Pending[key] = tmp
			}
		case "redelivered":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Redelivered == nil && sz > 0 {
				x.Redelivered = make(map[uint64]uint64, sz)
			} else if x.Redelivered != nil {
				clear(x.Redelivered)
			}
			for iRedelivered := uint32(0); iRedelivered < sz; iRedelivered++ {
				var key uint64
				key, v, err = cbor.ReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				var val uint64
				val, v, err = cbor.ReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				x.Redelivered[key] = val
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ConsumerState) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "delivered":

			v, err = (&x.Delivered).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "ack_floor":

			v, err = (&x.AckFloor).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "pending":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Pending == nil && sz > 0 {
				x.Pending = make(map[uint64]*Pending, sz)
			}
			for iPending := uint32(0); iPending < sz; iPending++ {
				var key uint64
				key, v, err = cbor.ReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				if len(v) == 0 {
					return b, cbor.ErrShortBytes
				}
				if v[0] == 0xf6 { // null
					var tmp []byte
					tmp, err = cbor.ReadNilBytes(v)
					if err != nil {
						return b, err
					}
					v = tmp
					x.Pending[key] = nil
					continue
				}
				val := new(Pending)
				v, err = val.DecodeTrusted(v)
				if err != nil {
					return b, err
				}
				x.Pending[key] = val
			}
		case "redelivered":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Redelivered == nil && sz > 0 {
				x.Redelivered = make(map[uint64]uint64, sz)
			}
			for iRedelivered := uint32(0); iRedelivered < sz; iRedelivered++ {
				var key uint64
				key, v, err = cbor.ReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				var val uint64
				val, v, err = cbor.ReadUint64Bytes(v)
				if err != nil {
					return b, err
				}
				x.Redelivered[key] = val
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ConsumerState) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x consumerAssignment) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("created") + cbor.TimeSize + cbor.StringPrefixSize + len("name") + cbor.StringPrefixSize + len(x.Name) + cbor.StringPrefixSize + len("stream") + cbor.StringPrefixSize + len(x.Stream)
	return
}

func (x *consumerAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	count++
	if !(x.State == nil) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cbor.AppendString(b, "client")
		b, err = cbor.AppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cbor.AppendString(b, "created")
	b, err = cbor.AppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "name")
	b, err = cbor.AppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "stream")
	b, err = cbor.AppendString(b, x.Stream), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "consumer")
	b, err = cbor.AppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "group")
	b, err = cbor.AppendPtrMarshaler(b, x.Group)
	if err != nil {
		return b, err
	}
	if !(x.State == nil) {
		b = cbor.AppendString(b, "state")
		b, err = cbor.AppendPtrMarshaler(b, x.State)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *consumerAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "stream":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		case "consumer":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *consumerAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cbor.UnsafeString(tmpBytes)
		case "stream":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Stream = cbor.UnsafeString(tmpBytes)
		case "consumer":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *consumerAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x streamAssignment) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("created") + cbor.TimeSize + cbor.StringPrefixSize + len("sync") + cbor.StringPrefixSize + len(x.Sync)
	return
}

func (x *streamAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	b = cbor.AppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cbor.AppendString(b, "client")
		b, err = cbor.AppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cbor.AppendString(b, "created")
	b, err = cbor.AppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "stream")
	b, err = cbor.AppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "group")
	b, err = cbor.AppendPtrMarshaler(b, x.Group)
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "sync")
	b, err = cbor.AppendString(b, x.Sync), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *streamAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Sync = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *streamAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Sync = cbor.UnsafeString(tmpBytes)
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *streamAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x WriteableConsumerAssignment) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("created") + cbor.TimeSize + cbor.StringPrefixSize + len("name") + cbor.StringPrefixSize + len(x.Name) + cbor.StringPrefixSize + len("stream") + cbor.StringPrefixSize + len(x.Stream)
	return
}

func (x *WriteableConsumerAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	count++
	if !(x.State == nil) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cbor.AppendString(b, "client")
		b, err = cbor.AppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cbor.AppendString(b, "created")
	b, err = cbor.AppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "name")
	b, err = cbor.AppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "stream")
	b, err = cbor.AppendString(b, x.Stream), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "consumer")
	b, err = cbor.AppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "group")
	b, err = cbor.AppendPtrMarshaler(b, x.Group)
	if err != nil {
		return b, err
	}
	if !(x.State == nil) {
		b = cbor.AppendString(b, "state")
		b, err = cbor.AppendPtrMarshaler(b, x.State)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *WriteableConsumerAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "stream":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Stream = tmp
		case "consumer":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *WriteableConsumerAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cbor.UnsafeString(tmpBytes)
		case "stream":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Stream = cbor.UnsafeString(tmpBytes)
		case "consumer":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "state":

			if x.State == nil {
				x.State = new(ConsumerState)
			}
			v, err = x.State.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *WriteableConsumerAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x WriteableStreamAssignment) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("created") + cbor.TimeSize + cbor.StringPrefixSize + len("sync") + cbor.StringPrefixSize + len(x.Sync)
	return
}

func (x *WriteableStreamAssignment) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	if !(x.Client == nil) {
		count++
	}
	count++
	count++
	count++
	count++
	if !(len(x.Consumers) == 0) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	if !(x.Client == nil) {
		b = cbor.AppendString(b, "client")
		b, err = cbor.AppendPtrMarshaler(b, x.Client)
		if err != nil {
			return b, err
		}
	}
	b = cbor.AppendString(b, "created")
	b, err = cbor.AppendTime(b, x.Created), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "stream")
	b, err = cbor.AppendBytes(b, []byte(x.ConfigJSON)), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "group")
	b, err = cbor.AppendPtrMarshaler(b, x.Group)
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "sync")
	b, err = cbor.AppendString(b, x.Sync), nil
	if err != nil {
		return b, err
	}
	if !(len(x.Consumers) == 0) {

		b = cbor.AppendString(b, "consumers")
		b = cbor.AppendArrayHeader(b, uint32(len(x.Consumers)))
		for _, w := range x.Consumers {
			if w == nil {
				b = cbor.AppendNil(b)
			} else {
				b, err = w.MarshalCBOR(b)
				if err != nil {
					return b, err
				}
			}
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *WriteableStreamAssignment) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Sync = tmp
		case "consumers":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Consumers) >= int(sz) {
				x.Consumers = x.Consumers[:sz]
			} else {
				x.Consumers = make([]*WriteableConsumerAssignment, sz)
			}
			if sz > 0 {
				_ = x.Consumers[sz-1]
			}
			for iConsumers := uint32(0); iConsumers < sz; iConsumers++ {
				if x.Consumers[iConsumers] == nil {
					x.Consumers[iConsumers] = new(WriteableConsumerAssignment)
				}
				v, err = x.Consumers[iConsumers].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *WriteableStreamAssignment) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "client":

			if x.Client == nil {
				x.Client = new(ClientInfo)
			}
			v, err = x.Client.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "created":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.Created = tmp
		case "stream":

			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		case "group":

			if x.Group == nil {
				x.Group = new(RaftGroup)
			}
			v, err = x.Group.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "sync":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Sync = cbor.UnsafeString(tmpBytes)
		case "consumers":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Consumers) >= int(sz) {
				x.Consumers = x.Consumers[:sz]
			} else {
				x.Consumers = make([]*WriteableConsumerAssignment, sz)
			}
			if sz > 0 {
				_ = x.Consumers[sz-1]
			}
			for iConsumers := uint32(0); iConsumers < sz; iConsumers++ {
				if x.Consumers[iConsumers] == nil {
					x.Consumers[iConsumers] = new(WriteableConsumerAssignment)
				}
				v, err = x.Consumers[iConsumers].DecodeTrusted(v)
				if err != nil {
					return b, err
				}
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *WriteableStreamAssignment) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x MetaSnapshot) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("streams") + cbor.ArrayHeaderSize + len(x.Streams)*0
	return
}

func (x *MetaSnapshot) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	b = cbor.AppendMapHeader(b, uint32(1))
	var err error

	b = cbor.AppendString(b, "streams")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Streams)))
	for i := range x.Streams {
		b, err = x.Streams[i].MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *MetaSnapshot) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "streams":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Streams) >= int(sz) {
				x.Streams = x.Streams[:sz]
			} else {
				x.Streams = make([]WriteableStreamAssignment, sz)
			}
			if sz > 0 {
				_ = x.Streams[sz-1]
			}
			for iStreams := uint32(0); iStreams < sz; iStreams++ {
				var tmp WriteableStreamAssignment
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Streams[iStreams] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *MetaSnapshot) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "streams":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Streams) >= int(sz) {
				x.Streams = x.Streams[:sz]
			} else {
				x.Streams = make([]WriteableStreamAssignment, sz)
			}
			if sz > 0 {
				_ = x.Streams[sz-1]
			}
			for iStreams := uint32(0); iStreams < sz; iStreams++ {
				var tmp WriteableStreamAssignment
				v, err = (&tmp).DecodeTrusted(v)
				if err != nil {
					return b, err
				}
				x.Streams[iStreams] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *MetaSnapshot) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x StreamConfigSnapshot) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("name") + cbor.StringPrefixSize + len(x.Name) + cbor.StringPrefixSize + len("subjects") + cbor.ArrayHeaderSize + len(x.Subjects)*cbor.StringPrefixSize + cbor.StringPrefixSize + len("metadata") + cbor.MapHeaderSize + len(x.Metadata)*(cbor.StringPrefixSize+cbor.StringPrefixSize)
	return
}

func (x *StreamConfigSnapshot) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	count++
	count++
	count++
	if !(len(x.Metadata) == 0) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	b = cbor.AppendString(b, "name")
	b, err = cbor.AppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}

	b = cbor.AppendString(b, "subjects")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Subjects)))
	for _, v := range x.Subjects {
		b = cbor.AppendString(b, v)
	}
	b = cbor.AppendString(b, "storage")
	b, err = x.Storage.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(len(x.Metadata) == 0) {

		b = cbor.AppendString(b, "metadata")
		b = cbor.AppendMapHeader(b, uint32(len(x.Metadata)))
		for k, v := range x.Metadata {
			b = cbor.AppendString(b, k)
			b = cbor.AppendString(b, v)
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *StreamConfigSnapshot) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "name":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "subjects":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Subjects) >= int(sz) {
				x.Subjects = x.Subjects[:sz]
			} else {
				x.Subjects = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Subjects[sz-1]
			}
			for iSubjects := uint32(0); iSubjects < sz; iSubjects++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Subjects[iSubjects] = tmp
			}
		case "storage":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "metadata":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Metadata == nil && sz > 0 {
				x.Metadata = make(map[string]string, sz)
			} else if x.Metadata != nil {
				clear(x.Metadata)
			}
			for iMetadata := uint32(0); iMetadata < sz; iMetadata++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Metadata[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *StreamConfigSnapshot) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cbor.UnsafeString(tmpBytes)
		case "subjects":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Subjects) >= int(sz) {
				x.Subjects = x.Subjects[:sz]
			} else {
				x.Subjects = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Subjects[sz-1]
			}
			for iSubjects := uint32(0); iSubjects < sz; iSubjects++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Subjects[iSubjects] = tmp
			}
		case "storage":

			v, err = x.Storage.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "metadata":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Metadata == nil && sz > 0 {
				x.Metadata = make(map[string]string, sz)
			} else if x.Metadata != nil {
				clear(x.Metadata)
			}
			for iMetadata := uint32(0); iMetadata < sz; iMetadata++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Metadata[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *StreamConfigSnapshot) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x ConsumerConfigSnapshot) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("durable") + cbor.StringPrefixSize + len(x.Durable) + cbor.StringPrefixSize + len("mem_storage") + cbor.BoolSize + cbor.StringPrefixSize + len("metadata") + cbor.MapHeaderSize + len(x.Metadata)*(cbor.StringPrefixSize+cbor.StringPrefixSize)
	return
}

func (x *ConsumerConfigSnapshot) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	count++
	count++
	if !(len(x.Metadata) == 0) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	b = cbor.AppendString(b, "durable")
	b, err = cbor.AppendString(b, x.Durable), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "mem_storage")
	b, err = cbor.AppendBool(b, x.MemoryStorage), nil
	if err != nil {
		return b, err
	}
	if !(len(x.Metadata) == 0) {

		b = cbor.AppendString(b, "metadata")
		b = cbor.AppendMapHeader(b, uint32(len(x.Metadata)))
		for k, v := range x.Metadata {
			b = cbor.AppendString(b, k)
			b = cbor.AppendString(b, v)
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *ConsumerConfigSnapshot) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "durable":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Durable = tmp
		case "mem_storage":

			var tmp bool
			tmp, v, err = cbor.ReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.MemoryStorage = tmp
		case "metadata":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Metadata == nil && sz > 0 {
				x.Metadata = make(map[string]string, sz)
			} else if x.Metadata != nil {
				clear(x.Metadata)
			}
			for iMetadata := uint32(0); iMetadata < sz; iMetadata++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Metadata[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *ConsumerConfigSnapshot) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "durable":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Durable = cbor.UnsafeString(tmpBytes)
		case "mem_storage":

			var tmp bool
			tmp, v, err = cbor.ReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.MemoryStorage = tmp
		case "metadata":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Metadata == nil && sz > 0 {
				x.Metadata = make(map[string]string, sz)
			} else if x.Metadata != nil {
				clear(x.Metadata)
			}
			for iMetadata := uint32(0); iMetadata < sz; iMetadata++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Metadata[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *ConsumerConfigSnapshot) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
