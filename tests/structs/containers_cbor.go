// Code generated by cborgen DO NOT EDIT.

package structs

import cbor "github.com/synadia-labs/cbor.go/runtime"

func (x Containers) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("items") + cbor.ArrayHeaderSize + len(x.Items)*0 + cbor.StringPrefixSize + len("map") + cbor.MapHeaderSize + len(x.Map)*(cbor.StringPrefixSize+0)
	return
}

func (x *Containers) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	b = cbor.AppendMapHeader(b, 4)
	var err error

	b = cbor.AppendString(b, "items")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Items)))
	for i := range x.Items {
		b, err = x.Items[i].MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}

	b = cbor.AppendString(b, "ptrs")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Ptrs)))
	for _, s := range x.Ptrs {
		if s == nil {
			b = cbor.AppendNil(b)
		} else {
			b, err = s.MarshalCBOR(b)
			if err != nil {
				return b, err
			}
		}
	}

	b = cbor.AppendString(b, "map")
	b = cbor.AppendMapHeader(b, uint32(len(x.Map)))
	for k, v := range x.Map {
		b = cbor.AppendString(b, k)
		b, err = v.MarshalCBOR(b)
		if err != nil {
			return b, err
		}
	}

	b = cbor.AppendString(b, "ptr_map")
	b = cbor.AppendMapHeader(b, uint32(len(x.PtrMap)))
	for k, v := range x.PtrMap {
		b = cbor.AppendString(b, k)
		if v == nil {
			b = cbor.AppendNil(b)
		} else {
			b, err = v.MarshalCBOR(b)
			if err != nil {
				return b, err
			}
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Containers) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "items":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Items) >= int(sz) {
				x.Items = x.Items[:sz]
			} else {
				x.Items = make([]Scalars, sz)
			}
			if sz > 0 {
				_ = x.Items[sz-1]
			}
			for iItems := uint32(0); iItems < sz; iItems++ {
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Items[iItems] = tmp
			}
		case "ptrs":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Ptrs) >= int(sz) {
				x.Ptrs = x.Ptrs[:sz]
			} else {
				x.Ptrs = make([]*Scalars, sz)
			}
			if sz > 0 {
				_ = x.Ptrs[sz-1]
			}
			for iPtrs := uint32(0); iPtrs < sz; iPtrs++ {
				if x.Ptrs[iPtrs] == nil {
					x.Ptrs[iPtrs] = new(Scalars)
				}
				v, err = x.Ptrs[iPtrs].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		case "map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Map == nil && sz > 0 {
				x.Map = make(map[string]Scalars, sz)
			} else if x.Map != nil {
				clear(x.Map)
			}
			for iMap := uint32(0); iMap < sz; iMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Map[key] = tmp
			}
		case "ptr_map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.PtrMap == nil && sz > 0 {
				x.PtrMap = make(map[string]*Scalars, sz)
			} else if x.PtrMap != nil {
				clear(x.PtrMap)
			}
			for iPtrMap := uint32(0); iPtrMap < sz; iPtrMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				tmp := new(Scalars)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.PtrMap[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Containers) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "items":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Items) >= int(sz) {
				x.Items = x.Items[:sz]
			} else {
				x.Items = make([]Scalars, sz)
			}
			if sz > 0 {
				_ = x.Items[sz-1]
			}
			for iItems := uint32(0); iItems < sz; iItems++ {
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Items[iItems] = tmp
			}
		case "ptrs":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Ptrs) >= int(sz) {
				x.Ptrs = x.Ptrs[:sz]
			} else {
				x.Ptrs = make([]*Scalars, sz)
			}
			if sz > 0 {
				_ = x.Ptrs[sz-1]
			}
			for iPtrs := uint32(0); iPtrs < sz; iPtrs++ {
				if x.Ptrs[iPtrs] == nil {
					x.Ptrs[iPtrs] = new(Scalars)
				}
				v, err = x.Ptrs[iPtrs].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		case "map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Map == nil && sz > 0 {
				x.Map = make(map[string]Scalars, sz)
			} else if x.Map != nil {
				clear(x.Map)
			}
			for iMap := uint32(0); iMap < sz; iMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Map[key] = tmp
			}
		case "ptr_map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.PtrMap == nil && sz > 0 {
				x.PtrMap = make(map[string]*Scalars, sz)
			} else if x.PtrMap != nil {
				clear(x.PtrMap)
			}
			for iPtrMap := uint32(0); iPtrMap < sz; iPtrMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				tmp := new(Scalars)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.PtrMap[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Containers) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
