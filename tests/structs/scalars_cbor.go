// Code generated by cborgen DO NOT EDIT.

package structs

import (
	"time"

	cbor "github.com/synadia-labs/cbor-go/runtime"
)

func (x Scalars) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("s") + cbor.StringPrefixSize + len(x.S) + cbor.StringPrefixSize + len("b") + cbor.BoolSize + cbor.StringPrefixSize + len("i") + cbor.IntSize + cbor.StringPrefixSize + len("i8") + cbor.Int8Size + cbor.StringPrefixSize + len("i16") + cbor.Int16Size + cbor.StringPrefixSize + len("i32") + cbor.Int32Size + cbor.StringPrefixSize + len("i64") + cbor.Int64Size + cbor.StringPrefixSize + len("u") + cbor.UintSize + cbor.StringPrefixSize + len("u8") + cbor.Uint8Size + cbor.StringPrefixSize + len("u16") + cbor.Uint16Size + cbor.StringPrefixSize + len("u32") + cbor.Uint32Size + cbor.StringPrefixSize + len("u64") + cbor.Uint64Size + cbor.StringPrefixSize + len("f32") + cbor.Float32Size + cbor.StringPrefixSize + len("f64") + cbor.Float64Size + cbor.StringPrefixSize + len("data") + cbor.BytesPrefixSize + len(x.Data) + cbor.StringPrefixSize + len("ints") + cbor.ArrayHeaderSize + len(x.Ints)*cbor.IntSize + cbor.StringPrefixSize + len("names") + cbor.ArrayHeaderSize + len(x.Names)*cbor.StringPrefixSize + cbor.StringPrefixSize + len("scores") + cbor.MapHeaderSize + len(x.Scores)*(cbor.StringPrefixSize+cbor.IntSize) + cbor.StringPrefixSize + len("t") + cbor.TimeSize + cbor.StringPrefixSize + len("d") + cbor.DurationSize
	return
}

func (x *Scalars) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	b = cbor.AppendMapHeader(b, uint32(20))
	var err error
	b = cbor.AppendString(b, "s")
	b, err = cbor.AppendString(b, x.S), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "b")
	b, err = cbor.AppendBool(b, x.B), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "i")
	b, err = cbor.AppendInt(b, x.I), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "i8")
	b, err = cbor.AppendInt8(b, x.I8), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "i16")
	b, err = cbor.AppendInt16(b, x.I16), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "i32")
	b, err = cbor.AppendInt32(b, x.I32), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "i64")
	b, err = cbor.AppendInt64(b, x.I64), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "u")
	b, err = cbor.AppendUint(b, x.U), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "u8")
	b, err = cbor.AppendUint8(b, x.U8), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "u16")
	b, err = cbor.AppendUint16(b, x.U16), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "u32")
	b, err = cbor.AppendUint32(b, x.U32), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "u64")
	b, err = cbor.AppendUint64(b, x.U64), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "f32")
	b, err = cbor.AppendFloat32(b, x.F32), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "f64")
	b, err = cbor.AppendFloat64(b, x.F64), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "data")
	b, err = cbor.AppendInterface(b, x.Data)
	if err != nil {
		return b, err
	}

	b = cbor.AppendString(b, "ints")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Ints)))
	for _, v := range x.Ints {
		b = cbor.AppendInt(b, v)
	}

	b = cbor.AppendString(b, "names")
	b = cbor.AppendArrayHeader(b, uint32(len(x.Names)))
	for _, v := range x.Names {
		b = cbor.AppendString(b, v)
	}

	b = cbor.AppendString(b, "scores")
	b = cbor.AppendMapHeader(b, uint32(len(x.Scores)))
	for k, v := range x.Scores {
		b = cbor.AppendString(b, k)
		b = cbor.AppendInt(b, v)
	}
	b = cbor.AppendString(b, "t")
	b, err = cbor.AppendTime(b, x.T), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "d")
	b, err = cbor.AppendDuration(b, x.D), nil
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Scalars) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "s":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.S = tmp
		case "b":

			var tmp bool
			tmp, v, err = cbor.ReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.B = tmp
		case "i":

			var tmp int
			tmp, v, err = cbor.ReadIntBytes(v)
			if err != nil {
				return b, err
			}
			x.I = tmp
		case "i8":

			var tmp int8
			tmp, v, err = cbor.ReadInt8Bytes(v)
			if err != nil {
				return b, err
			}
			x.I8 = tmp
		case "i16":

			var tmp int16
			tmp, v, err = cbor.ReadInt16Bytes(v)
			if err != nil {
				return b, err
			}
			x.I16 = tmp
		case "i32":

			var tmp int32
			tmp, v, err = cbor.ReadInt32Bytes(v)
			if err != nil {
				return b, err
			}
			x.I32 = tmp
		case "i64":

			var tmp int64
			tmp, v, err = cbor.ReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.I64 = tmp
		case "u":

			var tmp uint
			tmp, v, err = cbor.ReadUintBytes(v)
			if err != nil {
				return b, err
			}
			x.U = tmp
		case "u8":

			var tmp uint8
			tmp, v, err = cbor.ReadUint8Bytes(v)
			if err != nil {
				return b, err
			}
			x.U8 = tmp
		case "u16":

			var tmp uint16
			tmp, v, err = cbor.ReadUint16Bytes(v)
			if err != nil {
				return b, err
			}
			x.U16 = tmp
		case "u32":

			var tmp uint32
			tmp, v, err = cbor.ReadUint32Bytes(v)
			if err != nil {
				return b, err
			}
			x.U32 = tmp
		case "u64":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.U64 = tmp
		case "f32":

			var tmp float32
			tmp, v, err = cbor.ReadFloat32Bytes(v)
			if err != nil {
				return b, err
			}
			x.F32 = tmp
		case "f64":

			var tmp float64
			tmp, v, err = cbor.ReadFloat64Bytes(v)
			if err != nil {
				return b, err
			}
			x.F64 = tmp
		case "data":

			var tmp []byte
			tmp, v, err = cbor.ReadBytesBytes(v, nil)
			if err != nil {
				return b, err
			}
			x.Data = tmp
		case "ints":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Ints) >= int(sz) {
				x.Ints = x.Ints[:sz]
			} else {
				x.Ints = make([]int, sz)
			}
			if sz > 0 {
				_ = x.Ints[sz-1]
			}
			for iInts := uint32(0); iInts < sz; iInts++ {
				var tmp int
				tmp, v, err = cbor.ReadIntBytes(v)
				if err != nil {
					return b, err
				}
				x.Ints[iInts] = tmp
			}
		case "names":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Names) >= int(sz) {
				x.Names = x.Names[:sz]
			} else {
				x.Names = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Names[sz-1]
			}
			for iNames := uint32(0); iNames < sz; iNames++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Names[iNames] = tmp
			}
		case "scores":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Scores == nil && sz > 0 {
				x.Scores = make(map[string]int, sz)
			} else if x.Scores != nil {
				clear(x.Scores)
			}
			for iScores := uint32(0); iScores < sz; iScores++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp int
				tmp, v, err = cbor.ReadIntBytes(v)
				if err != nil {
					return b, err
				}
				x.Scores[key] = tmp
			}
		case "t":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.T = tmp
		case "d":

			var tmp time.Duration
			tmp, v, err = cbor.ReadDurationBytes(v)
			if err != nil {
				return b, err
			}
			x.D = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Scalars) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "s":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.S = cbor.UnsafeString(tmpBytes)
		case "b":

			var tmp bool
			tmp, v, err = cbor.ReadBoolBytes(v)
			if err != nil {
				return b, err
			}
			x.B = tmp
		case "i":

			var tmp int
			tmp, v, err = cbor.ReadIntBytes(v)
			if err != nil {
				return b, err
			}
			x.I = tmp
		case "i8":

			var tmp int8
			tmp, v, err = cbor.ReadInt8Bytes(v)
			if err != nil {
				return b, err
			}
			x.I8 = tmp
		case "i16":

			var tmp int16
			tmp, v, err = cbor.ReadInt16Bytes(v)
			if err != nil {
				return b, err
			}
			x.I16 = tmp
		case "i32":

			var tmp int32
			tmp, v, err = cbor.ReadInt32Bytes(v)
			if err != nil {
				return b, err
			}
			x.I32 = tmp
		case "i64":

			var tmp int64
			tmp, v, err = cbor.ReadInt64Bytes(v)
			if err != nil {
				return b, err
			}
			x.I64 = tmp
		case "u":

			var tmp uint
			tmp, v, err = cbor.ReadUintBytes(v)
			if err != nil {
				return b, err
			}
			x.U = tmp
		case "u8":

			var tmp uint8
			tmp, v, err = cbor.ReadUint8Bytes(v)
			if err != nil {
				return b, err
			}
			x.U8 = tmp
		case "u16":

			var tmp uint16
			tmp, v, err = cbor.ReadUint16Bytes(v)
			if err != nil {
				return b, err
			}
			x.U16 = tmp
		case "u32":

			var tmp uint32
			tmp, v, err = cbor.ReadUint32Bytes(v)
			if err != nil {
				return b, err
			}
			x.U32 = tmp
		case "u64":

			var tmp uint64
			tmp, v, err = cbor.ReadUint64Bytes(v)
			if err != nil {
				return b, err
			}
			x.U64 = tmp
		case "f32":

			var tmp float32
			tmp, v, err = cbor.ReadFloat32Bytes(v)
			if err != nil {
				return b, err
			}
			x.F32 = tmp
		case "f64":

			var tmp float64
			tmp, v, err = cbor.ReadFloat64Bytes(v)
			if err != nil {
				return b, err
			}
			x.F64 = tmp
		case "data":

			var tmp []byte
			tmp, v, err = cbor.ReadBytesBytes(v, nil)
			if err != nil {
				return b, err
			}
			x.Data = tmp
		case "ints":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Ints) >= int(sz) {
				x.Ints = x.Ints[:sz]
			} else {
				x.Ints = make([]int, sz)
			}
			if sz > 0 {
				_ = x.Ints[sz-1]
			}
			for iInts := uint32(0); iInts < sz; iInts++ {
				var tmp int
				tmp, v, err = cbor.ReadIntBytes(v)
				if err != nil {
					return b, err
				}
				x.Ints[iInts] = tmp
			}
		case "names":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Names) >= int(sz) {
				x.Names = x.Names[:sz]
			} else {
				x.Names = make([]string, sz)
			}
			if sz > 0 {
				_ = x.Names[sz-1]
			}
			for iNames := uint32(0); iNames < sz; iNames++ {
				var tmp string
				tmp, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				x.Names[iNames] = tmp
			}
		case "scores":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Scores == nil && sz > 0 {
				x.Scores = make(map[string]int, sz)
			} else if x.Scores != nil {
				clear(x.Scores)
			}
			for iScores := uint32(0); iScores < sz; iScores++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp int
				tmp, v, err = cbor.ReadIntBytes(v)
				if err != nil {
					return b, err
				}
				x.Scores[key] = tmp
			}
		case "t":

			var tmp time.Time
			tmp, v, err = cbor.ReadTimeBytes(v)
			if err != nil {
				return b, err
			}
			x.T = tmp
		case "d":

			var tmp time.Duration
			tmp, v, err = cbor.ReadDurationBytes(v)
			if err != nil {
				return b, err
			}
			x.D = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Scalars) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}

func (x Nested) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("id") + cbor.StringPrefixSize + len(x.ID)
	return
}

func (x *Nested) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(0)
	count++
	count++
	if !(x.Ptr == nil) {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	b = cbor.AppendString(b, "id")
	b, err = cbor.AppendString(b, x.ID), nil
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "base")
	b, err = x.Base.MarshalCBOR(b)
	if err != nil {
		return b, err
	}
	if !(x.Ptr == nil) {
		b = cbor.AppendString(b, "ptr")
		b, err = cbor.AppendPtrMarshaler(b, x.Ptr)
		if err != nil {
			return b, err
		}
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Nested) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "id":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.ID = tmp
		case "base":

			v, err = x.Base.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		case "ptr":

			if x.Ptr == nil {
				x.Ptr = new(Scalars)
			}
			v, err = x.Ptr.UnmarshalCBOR(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Nested) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "id":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.ID = cbor.UnsafeString(tmpBytes)
		case "base":

			v, err = (&x.Base).DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		case "ptr":

			if x.Ptr == nil {
				x.Ptr = new(Scalars)
			}
			v, err = x.Ptr.DecodeTrusted(v)
			if err != nil {
				return b, err
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Nested) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
