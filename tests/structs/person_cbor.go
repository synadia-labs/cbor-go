// Code generated by cborgen DO NOT EDIT.

package structs

import cbor "github.com/synadia-labs/cbor.go/runtime"

func (x Person) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("name") + cbor.StringPrefixSize + len(x.Name) + cbor.StringPrefixSize + len("age") + cbor.IntSize + cbor.StringPrefixSize + len("data") + cbor.BytesPrefixSize + len(x.Data)
	return
}

func (x *Person) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	count := uint32(2)
	if x.Age != 0 {
		count++
	}
	b = cbor.AppendMapHeader(b, count)
	var err error
	b = cbor.AppendString(b, "name")
	b = cbor.AppendString(b, x.Name)
	if x.Age != 0 {
		b = cbor.AppendString(b, "age")
		b = cbor.AppendInt(b, x.Age)
	}
	b = cbor.AppendString(b, "data")
	b, err = cbor.AppendInterface(b, x.Data)
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Person) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "name":

			var tmp string
			tmp, v, err = cbor.ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "age":

			var tmp int
			tmp, v, err = cbor.ReadIntBytes(v)
			if err != nil {
				return b, err
			}
			x.Age = tmp
		case "data":

			var tmp []byte
			tmp, v, err = cbor.ReadBytesBytes(v, nil)
			if err != nil {
				return b, err
			}
			x.Data = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Person) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = cbor.ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = cbor.UnsafeString(tmpBytes)
		case "age":

			var tmp int
			tmp, v, err = cbor.ReadIntBytes(v)
			if err != nil {
				return b, err
			}
			x.Age = tmp
		case "data":

			var tmp []byte
			tmp, v, err = cbor.ReadBytesBytes(v, nil)
			if err != nil {
				return b, err
			}
			x.Data = tmp
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Person) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
